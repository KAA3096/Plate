import streamlit as st
import base64
import pandas as pd

menu = st.sidebar.radio(
    '***',
    (
        "Аппроксимация полиномами степени $p = 1,2,3$",
        "Сравнение результатов",
        "Циркулляция",
        "Полувысота",
        "Программная реализация"
    )
)

def load_gif(gif_path):
    try:
        with open(gif_path, "rb") as file_:
            contents = file_.read()
            data_url = base64.b64encode(contents).decode("utf-8")
            return st.markdown(
                f'<img src="data:image/gif;base64,{data_url}" width="100%">',
                unsafe_allow_html=True,
            )
    except FileNotFoundError:
        st.error(f"Файл {gif_path} не найден!")
    except Exception as e:
        st.error(f"Ошибка загрузки GIF: {str(e)}")

if menu == "Аппроксимация полиномами степени $p = 1,2,3$":
    r"""
    ##### Численное решение задачи вихре-потенциального симметричного обтекания пластины в канале при аппроксимации полиномами степени $p = 1,2,3$ 
    """
    
    mesh_size = st.selectbox(
        "Размер сетки",  
        ["4393", "15283", "66427"]  
    )
    
    poly_degree = st.selectbox(
        "Степень полинома",  
        ["p = 1", "p = 2", "p = 3"]  
    )

    if mesh_size == "4393":
        if poly_degree == "p = 1":
            load_gif("4393_p1.gif")
            r"""
            -----------------------------------------------
            * Число ячеек сетки: 4393
            * Число узлов сетки: 2333
            * Число искомых дискретных значений: 2333
            * Макс. завихренность: 3.734975
            * Мин. завихренность: -18.026918
            * Число итераций: 12
            * $\Gamma = -1$
            * $\omega_0 = -2.0$
            ------------------------------------------------
            """
            
        elif poly_degree == "p = 2":
            load_gif("4393_p2.gif")
            r"""
            -----------------------------------------------
            * Число ячеек сетки: 4393
            * Число узлов сетки: 2333
            * Число искомых дискретных значений: 9058
            * Макс. завихренность: 5.860120
            * Мин. завихренность: -21.511346
            * Число итераций: 19
            * $\Gamma = -1$
            * $\omega_0 = -2.0$
            ------------------------------------------------
            """
            
        elif poly_degree == "p = 3":
            load_gif("4393_p3.gif")
            r"""
            -----------------------------------------------
            * Число ячеек сетки: 4393
            * Число узлов сетки: 2333
            * Число искомых дискретных значений: 20176
            * Макс. завихренность: 5.962610
            * Мин. завихренность: -21.255899
            * Число итераций: 15
            * $\Gamma = -1$
            * $\omega_0 = -2.0$
            ------------------------------------------------
            """
    if mesh_size == "15283":
        if poly_degree == "p = 1":
            load_gif("15283_p1.gif")
            r"""
            -----------------------------------------------
            * Число ячеек сетки: 15283
            * Число узлов сетки: 7999
            * Число искомых дискретных значений: 7999
            * Макс. завихренность: 3.905896
            * Мин. завихренность: -17.746363
            * Число итераций: 14
            * $\Gamma = -1$
            * $\omega_0 = -2.0$
            ------------------------------------------------
            """
            
        elif poly_degree == "p = 2":
            load_gif("15283_p2.gif")
            r"""
            -----------------------------------------------
            * Число ячеек сетки: 15283
            * Число узлов сетки: 7999
            * Число искомых дискретных значений: 31280
            * Макс. завихренность: 7.211165
            * Мин. завихренность: -21.394293
            * Число итераций: 11
            * $\Gamma = -1$
            * $\omega_0 = -2.0$
            ------------------------------------------------
            """
            
        elif poly_degree == "p = 3":
            load_gif("15283_p3.gif")
            r"""
            -----------------------------------------------
            * Число ячеек сетки: 15283
            * Число узлов сетки: 7999
            * Число искомых дискретных значений: 698442
            * Макс. завихренность: 6.332100
            * Мин. завихренность: -20.520577
            * Число итераций: 13
            * $\Gamma = -1$
            * $\omega_0 = -2.0$
            ------------------------------------------------
            """
            
    if mesh_size == "66427":
        if poly_degree == "p = 1":
            load_gif("66427_p1.gif")
            r"""
            -----------------------------------------------
            * Число ячеек сетки: 66427
            * Число узлов сетки: 34492
            * Число искомых дискретных значений: 34492
            * Макс. завихренность: 4.459126
            * Мин. завихренность: -18.050687
            * Число итераций: 10
            * $\Gamma = -1$
            * $\omega_0 = -2.0$
            ------------------------------------------------
            """
            
        elif poly_degree == "p = 2":
            load_gif("66427_p2.gif")
            r"""
            -----------------------------------------------
            * Число ячеек сетки: 66427
            * Число узлов сетки: 34492
            * Число искомых дискретных значений: 135410
            * Макс. завихренность: 6.869948
            * Мин. завихренность: -21.333706
            * Число итераций: 12
            * $\Gamma = -1$
            * $\omega_0 = -2.0$
            ------------------------------------------------
            """
            
        elif poly_degree == "p = 3":
            load_gif("66427_p3.gif")
            r"""
            -----------------------------------------------
            * Число ячеек сетки: 66427
            * Число узлов сетки: 34492
            * Число искомых дискретных значений: 302755
            * Макс. завихренность: 6.306304
            * Мин. завихренность: -20.528418
            * Число итераций: 19
            * $\Gamma = -1$
            * $\omega_0 = -2.0$
            ------------------------------------------------
            """
if menu == "Сравнение результатов":
    r"""
    ##### Число искомых дискретных значений в зависимости от размера сетки и порядка аппроксимации  $p$
    """
    data = {
        "Размер сетки": [4393, 15283, 66427],
        "Ст. свободы": [2333, 7999, 34492],
        "Макс. завихр.": [3.73, 3.91, 4.46],
        "Мин. завихр.": [-18.03, -17.75, -18.05]
    }

    df_p1 = pd.DataFrame({
        "Размер сетки": data["Размер сетки"],
        "Степени свободы": data["Ст. свободы"],
        "Макс. завихренность": data["Макс. завихр."],
        "Мин. завихренность": data["Мин. завихр."]
    })
    
    data = {    
        "Размер сетки": [4393, 15283, 66427],
        "Ст. свободы": [9058, 31280, 135410],
        "Макс. завихр.": [5.86, 7.21, 6.87],
        "Мин. завихр.": [-21.51, -21.39, -21.33]
    }

    df_p2 = pd.DataFrame({
        "Размер сетки": data["Размер сетки"],
        "Степени свободы": data["Ст. свободы"],
        "Макс. завихренность": data["Макс. завихр."],
        "Мин. завихренность": data["Мин. завихр."]
    })
    
    data = { 
        "Размер сетки": [4393, 15283, 66427],
        "Ст. свободы": [20176, 698442, 302755],
        "Макс. завихр.": [5.96, 6.33, 6.31],
        "Мин. завихр.": [-21.26, -20.52, -20.53]
    }

    df_p3 = pd.DataFrame({
        "Размер сетки": data["Размер сетки"],
        "Степени свободы": data["Ст. свободы"],
        "Макс. завихренность": data["Макс. завихр."],
        "Мин. завихренность": data["Мин. завихр."]
    })


    r"""Порядок аппроксимации $p = 1$"""
    st.dataframe(
        df_p1,
        hide_index=True,
        use_container_width=True,
        column_config={
            "Размер сетки": st.column_config.NumberColumn(width="small"),
            "Степени свободы": st.column_config.NumberColumn(width="medium"),
            "Макс. завихренность": st.column_config.NumberColumn(format="%.2f"),
            "Мин. завихренность": st.column_config.NumberColumn(format="%.2f")
        }
    )

    r"""Порядок аппроксимации $p = 2$"""
    st.dataframe(
        df_p2,
        hide_index=True,
        use_container_width=True,
        column_config={
            "Размер сетки": st.column_config.NumberColumn(width="small"),
            "Степени свободы": st.column_config.NumberColumn(width="medium"),
            "Макс. завихренность": st.column_config.NumberColumn(format="%.2f"),
            "Мин. завихренность": st.column_config.NumberColumn(format="%.2f")
        }
    )

    r"""Порядок аппроксимации $p = 3$"""
    st.dataframe(
        df_p3,
        hide_index=True,
        use_container_width=True,
        column_config={
            "Размер сетки": st.column_config.NumberColumn(width="small"),
            "Степени свободы": st.column_config.NumberColumn(width="medium"),
            "Макс. завихренность": st.column_config.NumberColumn(format="%.2f"),
            "Мин. завихренность": st.column_config.NumberColumn(format="%.2f")
        }
    )
            
if menu == "Циркулляция":
    r"""
    ##### Численное решение задачи вихре-потенциального симметричного обтекания пластины в канале при различной циркуляции $\Gamma$ 
    """
    gamma = st.selectbox(
        "Значение циркуляции",  
        ["-0.5", "-1", "-2"]  
    )
    
    if gamma == "-0.5":
        load_gif("gamma2_05.gif")
        r"""
            -----------------------------------------------
            * Число ячеек сетки: 15283
            * Число узлов сетки: 7999
            * Число искомых дискретных значений: 7999
            * Макс. завихренность: 5.152000
            * Мин. завихренность: -21.807968
            * Число итераций: 11
            * $\omega_0 = -2$
            * p = 1
            ------------------------------------------------
        """
    if gamma == "-1":
        load_gif("gamma2_1.gif")
        r"""
            -----------------------------------------------
            * Число ячеек сетки: 15283
            * Число узлов сетки: 7999
            * Число искомых дискретных значений: 7999
            * Макс. завихренность: 4.459126
            * Мин. завихренность: -18.050687
            * Число итераций: 10
            * $\omega_0 = -2$
            * p = 1
            ------------------------------------------------
        """
    if gamma == "-2":
        load_gif("gamma2_2.gif")
        r"""
            -----------------------------------------------
            * Число ячеек сетки: 15283
            * Число узлов сетки: 7999
            * Число искомых дискретных значений: 7999
            * Макс. завихренность: 3.871740
            * Мин. завихренность: -16.011488
            * Число итераций: 13
            * $\omega_0 = -2$
            * p = 1
            ------------------------------------------------
        """
        
if menu == "Полувысота":
    r"""
    ##### Численное решение задачи вихре-потенциального симметричного обтекания пластины в канале при изменении полувысоты пластины $h$
    """
    
    height = st.selectbox(
        "Полувысота пластины",  
        ["0.25", "0.75"]  
    )
    
    if height == "0.25":
        load_gif("height2_025.gif")
        r"""
            -----------------------------------------------
            * Число ячеек сетки: 15283
            * Число узлов сетки: 7999
            * Число искомых дискретных значений: 7999
            * Макс. завихренность: 3.922733
            * Мин. завихренность: -21.159928
            * Число итераций: 17
            * $\Gamma = -2$
            * $\omega_0 = -2$
            * p = 1
            ------------------------------------------------
        """
    if height == "0.75":
        load_gif("height2_075.gif")
        r"""
            -----------------------------------------------
            * Число ячеек сетки: 15283
            * Число узлов сетки: 7999
            * Число искомых дискретных значений: 7999
            * Макс. завихренность: 2.322699
            * Мин. завихренность: -11.729287
            * Итераций: 86
            * $\Gamma = -3$
            * $\omega_0 = -2$
            * p = 1
            ------------------------------------------------
        """
if menu == "Программная реализация":
    r"""
    ##### Программная реализация
    """
    with st.expander("Определение функционального пространства"):
        code = """
mesh = Mesh("minminplate.xml")                       # Загрузка сетки
boundaries = MeshFunction("size_t", mesh, "minminplate_facet_region.xml")  # Загрузка границ
ds = Measure("ds", subdomain_data=boundaries)        # Мера для граничных интегралов

deg = 1                                              # Степень аппроксимации
V = FunctionSpace(mesh, "CG", deg)                   # Функциональное пространство
"""
        st.code(code, language="python")
    
    with st.expander("Информация о сетке"):
        code = """
n_c = mesh.num_cells()                               # Число ячеек
n_v = mesh.num_vertices()                            # Число вершин
n_d = V.dim()                                        # Число степеней свободы
n = FacetNormal(mesh)                                # Нормали к граням

print(f"Число ячеек сетки: {n_c}")                   # Вывод информации
print(f"Число узлов сетки: {n_v}")
print(f"Число искомых дискретных значений: {n_d}")
"""
        st.code(code, language="python")
    
    with st.expander("Вариационная постановка задачи"):
        code = """
u = TrialFunction(V)                                 # Пробная функция (ψ)
v = TestFunction(V)                                  # Тестовая функция
f = Constant(0.0)                                    # Правая часть (0 для уравнения Пуассона)
"""
        st.code(code, language="python")
    
    with st.expander("Граничные условия"):
        code = """
u_l = Expression("x[1]", degree=deg)                 # Выражения для границ
u_r = Expression("x[1]", degree=deg)
u_t = Expression("x[1]", degree=deg)
u_b = Expression("0.0", degree=deg)

bcs1 = [                                             # Граничные условия:
        #DirichletBC(V, u_l, boundaries, 2),        # Левая граница 
        #DirichletBC(V, u_r, boundaries, 3),        # Правая граница 
        DirichletBC(V, u_t, boundaries, 4),         # Верхняя граница (ψ = y)
        DirichletBC(V, u_b, boundaries, 5)]         # Нижняя граница (ψ = 0)
"""
        st.code(code, language="python")
    
    with st.expander("Начальные условия"):
        code = """
Gamma = -2.0                                         # Заданная циркуляция
omega_0 = '-2.0'                                     # Начальная завихренность
omega_k = Function(V)                                # Функция для завихренности
omega_k.interpolate(Expression(omega_0, degree=deg)) # Инициализация ω
u_k = Function(V)                                    # Функция для ψ
"""
        st.code(code, language="python")

    with st.expander("Основной итерационный цикл"):
        code = """
# === Итерационный процесс ===
max_iter = 20                                        # Максимальное количество итераций
tolerance = 1e-12                                    # Допустимая погрешность для сходимости

u_prev = None                                        # Переменная для хранения предыдущего решения

for k in range(max_iter):                            # Основной итерационный цикл
    print(f"\n== Итерация {k} ==")
    
    # === Вариационное решение уравнения Пуассона ===
    # Формулировка слабой формы: ∫∇ψ·∇v dx = ∫ω v dx
    a = dot(grad(u), grad(v)) * dx                   # Билинейная форма (левая часть)
    L = omega_k * v * dx                             # Линейная форма (правая часть)
    solve(a == L, u_k, bcs1)                         # Решение вариационной задачи с граничными условиями

    # === Определение вихревой зоны ===
    X, Y = SpatialCoordinate(mesh)                   # Получение пространственных координат
    
    # Индикаторная функция для области с отрицательной функцией тока
    # и в заданной прямоугольной области [x>1.65, 0<y<0.5]
    indicator = conditional(                         
        lt(u_k, 0.0),                               # Условие: ψ < 0
        conditional(                                 # Дополнительное ограничение области
            And(gt(X, 1.65), And(gt(Y, 0.0), lt(Y, 0.5))),
            1.0, 0.0),
        0.0
    )
    
    # === Вычисление площади вихревой зоны ===
    area_negative_u = assemble(indicator * dx)       # Численное интегрирование индикаторной функции
    
    # === Проверка на исчезновение вихревой зоны ===
    if near(area_negative_u, 0.0):
        print("Область ψ < 0 исчезла, остановка итераций")
        break                                        # Прерывание цикла при отсутствии вихревой зоны

    # === Обновление завихренности в вихревой зоне ===
    # Выражение для новой завихренности:
    # ω = Γ/S в области ψ<0 и в заданном прямоугольнике, иначе 0
    omega_expr = conditional(
        lt(u_k, 0.0),                               # Только в области с ψ < 0
        conditional(                                 # Дополнительное ограничение области
            And(gt(X, 1.65), And(gt(Y, 0.0), lt(Y, 0.5))),
            Constant(Gamma / area_negative_u),      # Равномерное распределение завихренности
            Constant(0.0)),
        Constant(0.0)
    )
    
    # Проекция выражения завихренности в функциональное пространство
    omega_k = project(omega_expr, V)
    
    # Получение значений завихренности в узлах сетки
    omega_array = omega_k.vector().get_local()       
    print(f"Макс. завихренность: {np.max(omega_array):.6f}")  # Вывод максимального значения
    print(f"Мин. завихренность: {np.min(omega_array):.6f}")   # Вывод минимального значения

    # === Проверка сходимости ===
    if k > 0:
        # Вычисление L2-нормы разницы между текущим и предыдущим решением
        change = errornorm(u_k, u_prev, 'L2')        
        print(f"Изменение решения: {change}")
        
        # Проверка критерия сходимости
        if change < tolerance:                       
            print("Достигнута сходимость")
            break                                    # Прерывание цикла при достижении сходимости
    
    # === Сохранение текущего решения для следующей итерации ===
    if u_prev is None:
        u_prev = Function(V)                         # Инициализация при первой итерации
    u_prev.assign(u_k)                               # Копирование текущего решения
"""
        st.code(code, language="python")

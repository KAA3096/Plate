import streamlit as st
import base64

menu = st.sidebar.radio(
    '***',
    (
        "Модель Навье-Стокса",
        "Сравнение с моделью Навье-Стокса",
        "Программная реализация",
        "Наклонная пластина"
    )
)

def load_gif(gif_path):
    try:
        with open(gif_path, "rb") as file_:
            contents = file_.read()
            data_url = base64.b64encode(contents).decode("utf-8")
            return st.markdown(
                f'<img src="data:image/gif;base64,{data_url}" width="100%">',
                unsafe_allow_html=True,
            )
    except FileNotFoundError:
        st.error(f"Файл {gif_path} не найден!")
    except Exception as e:
        st.error(f"Ошибка загрузки GIF: {str(e)}")

if menu == "Модель Навье-Стокса":
    r"""
    ##### Модель Навье-Стокса 
    
    **Уравнения Навье-Стокса** для несжимаемой жидкости:
 

    $\begin{aligned}\frac{\partial \mathbf{u}}{\partial t} + (\mathbf{u} \cdot \nabla) \mathbf{u} = 
    -\frac{1}{\rho} \nabla p + \nu \nabla^2 \mathbf{u}\end{aligned}$ 
  
    
     $\begin{aligned}\nabla \cdot \mathbf{u} = 0
    \end{aligned}$
    
    где:
    
    $\mathbf{u} - $вектор скорости;
    
    $p - $ давление;
    
    $\rho - $ плотность жидкости;
    
    $\nu - $ кинематическая вязкость.
    
    **Масштабирование:**
    
    Для обобщения результатов введем безразмерные переменные:
    
    - пространственные координаты: $\bar{x} = x / H$, $\bar{y} = y / H$
    - скорость: $\bar{\mathbf{u}} = \mathbf{u} / U$
    - время: $\bar{t} = H^2 / \nu$
    - давление: $\bar{p} = p H / (\mu U)$
    
    где $U -$ характерная скорость на входе, $H -$ пространственный масштаб;
    
    После масштабирования уравнения принимают вид:
    
     $\begin{aligned}\frac{\partial \bar{\mathbf{u}}}{\partial \bar{t}} + {\operatorname{Re}}(\bar{\mathbf{u}} \cdot \nabla) \bar{\mathbf{u}} = 
    -\nabla \bar{p} + \nabla^2 \bar{\mathbf{u}}\end{aligned}$
    
    $\begin{aligned}\nabla \cdot \bar{\mathbf{u}} = 0\end{aligned}$
    
    где $\operatorname{Re} = \frac{\rho U L}{\mu}$ — число Рейнольдса, $\mu -$ динамическая вязкость, $\nu = \mu / \rho$.
    
    """
if menu == "Сравнение с моделью Навье-Стокса":
    r"""
    ##### Сравнение расчетных данных функций тока и геометрии вихревой зоны с данными по модели Навье-Стокса
    """
    time = st.selectbox(
        "Время",  
        ["0.002", "0.084", "0.164", "0.276", "0.402", "0.928", "1.822", "2.554", "3.742"]  
    )
    
    if time == "0.002":
        load_gif("0.002.png")
        
    if time == "0.084":
        load_gif("0.084.png")

    if time == "0.164":
        load_gif("0.164.png")
        
    if time == "0.276":
        load_gif("0.276.png")
        
    if time == "0.402":
        load_gif("0.402.png")
        
    if time == "0.928":
        load_gif("0.928.png")

    if time == "1.822":
        load_gif("1.822.png")
        
    if time == "2.554":
        load_gif("2.554.png")

    if time == "3.742":
        load_gif("3.742.png")
  
if menu == "Программная реализация":
    r"""
    ##### Программная реализация 
    """
    with st.expander("Определение функциональных пространств"):
        code = """
            # Пространства
            V = VectorFunctionSpace(mesh, 'P', 1)  # Пространство для скорости
            Q = FunctionSpace(mesh, 'P', 1)         # Пространство для давления
        """
        st.code(code, language="python")
        
    with st.expander("Граничные условия"):
        code = """
            # Граничные условия для скорости
            inflow_profile = Expression(('1.0', '0.0'), degree=2)
            bcu_inflow = DirichletBC(V, inflow_profile, boundaries, 2)  # Вход
            bcu_walls  = DirichletBC(V, Constant((1, 0)), boundaries, 4)  # Стенки
            bcu_plate  = DirichletBC(V, Constant((0, 0)), boundaries, 5)  # Пластина
            bcu = [bcu_inflow, bcu_walls, bcu_plate]

            # Граничное условие для давления (на выходе)
            bcp_outflow = DirichletBC(Q, Constant(0), boundaries, 3)
            bcp = [bcp_outflow]
        """
        st.code(code, language="python")
        
    with st.expander("Определение форм и функций"):
        code = """
            u = TrialFunction(V)  # Пробная функция для скорости
            v = TestFunction(V)   # Тестовая функция для скорости
            p = TrialFunction(Q)  # Пробная функция для давления
            q = TestFunction(Q)   # Тестовая функция для давления

            u_n = Function(V)     # Скорость на предыдущем шаге
            u_  = Function(V)     # Текущая скорость
            p_n = Function(Q)     # Давление на предыдущем шаге
            p_  = Function(Q)     # Текущее давление
        """
        st.code(code, language="python")
        
    with st.expander("Формулировка слабых форм уравнений"):
        code = """
            # Тензор напряжений
            def sigma(u, p):
                return 2*mu*epsilon(u) - p*Identity(len(u))

            # Слабая форма для уравнения Навье-Стокса
            F1 = rho*dot((u - u_n)/k, v)*dx + ... 
            a1 = lhs(F1)
            L1 = rhs(F1)

            # Слабая форма для уравнения Пуассона (давление)
            a2 = dot(nabla_grad(p), nabla_grad(q))*dx
            L2 = ... 

            # Слабая форма для коррекции скорости
            a3 = dot(u, v)*dx
            L3 = ... 
        """
        st.code(code, language="python")
        
    with st.expander("Сборка матриц и применение граничных условий"):
        code = """
            A1 = assemble(a1)
            A2 = assemble(a2)
            A3 = assemble(a3)
            [bc.apply(A1) for bc in bcu]  # Применение граничных условий для скорости
            [bc.apply(A2) for bc in bcp]  # Применение граничных условий для давления
        """
        st.code(code, language="python")
        
    with st.expander("Временной цикл"):
        code = """
            for n in range(num_steps):
                t += dt
                # Решение для скорости
                solve(A1, u_.vector(), b1, 'bicgstab', 'hypre_amg')
                # Решение для давления
                solve(A2, p_.vector(), b2, 'bicgstab', 'hypre_amg')
                # Коррекция скорости
                solve(A3, u_.vector(), b3, 'cg', 'sor')
                # Сохранение результатов
                xdmffile_u.write(u_, t)
                timeseries_u.store(u_.vector(), t)
                # Обновление переменных
                u_n.assign(u_)
                p_n.assign(p_)
        """
        st.code(code, language="python")
        
if menu == "Наклонная пластина":

    r"""
    ##### Численное решение задачи вихре-потенциального симметричного обтекания пластины в канале при различном наклоне пластины и аппроксимации полиномами степени $p = 1,2,3$ 
    """
    
    angular = st.selectbox(
        "Угол наклона",  
        ["30", "60", "72"]  
    )
    
    poly_degree = st.selectbox(
        "Степень полинома",  
        ["p = 1", "p = 2", "p = 3"]  
    )
    
    if angular == "30":
        if poly_degree == "p = 1":
            load_gif("angular30_p1.gif")
            r"""
            -----------------------------------------------
            * Число ячеек сетки: 13369
            * Число узлов сетки: 6930
            * Число искомых дискретных значений: 6930
            * Число итераций: 12 
            * Макс. завихренность: 6.981500
            * Мин. завихренность: -12.815237
            * $\Gamma =$ -2
            ------------------------------------------------
            """
            
        elif poly_degree == "p = 2":
            load_gif("angular30_p2.gif")
            r"""
            -----------------------------------------------
            * Число ячеек сетки: 13369
            * Число узлов сетки: 6930
            * Число искомых дискретных значений: 6930
            * Число итераций: 29 
            * Макс. завихренность: 4.849296
            * Мин. завихренность: -15.250735
            * $\Gamma =$ -2
            ------------------------------------------------
            """
        elif poly_degree == "p = 3":
            load_gif("angular30_p3.gif")
            r"""
            -----------------------------------------------
            * Число ячеек сетки: 13369
            * Число узлов сетки: 6930
            * Число искомых дискретных значений: 6930
            * Число итераций: 18 
            * Макс. завихренность: 4.431095
            * Мин. завихренность: -14.887584
            * $\Gamma =$ -2
            ------------------------------------------------
            """
    if angular == "60":
        if poly_degree == "p = 1":
            load_gif("angular60_p1.gif")
            r"""
            -----------------------------------------------
            * Число ячеек сетки: 12791
            * Число узлов сетки: 6641
            * Число искомых дискретных значений: 6641
            * Число итераций: 14 
            * Макс. завихренность: 8.813399
            * Мин. завихренность: -18.699571
            * $\Gamma =$ -2
            ------------------------------------------------
            """
            
        elif poly_degree == "p = 2":
            load_gif("angular60_p2.gif")
            r"""
            -----------------------------------------------
            * Число ячеек сетки: 12791
            * Число узлов сетки: 6641
            * Число искомых дискретных значений: 6641
            * Число итераций: 16 
            * Макс. завихренность: 6.422853
            * Мин. завихренность: -22.718509
            * $\Gamma =$ -2
            ------------------------------------------------
            """
            
        elif poly_degree == "p = 3":
            load_gif("angular60_p3.gif")
            r"""
            -----------------------------------------------
            * Число ячеек сетки: 12791
            * Число узлов сетки: 6641
            * Число искомых дискретных значений: 6641
            * Число итераций: 22 
            * Макс. завихренность: 5.945463
            * Мин. завихренность: -20.669287
            * $\Gamma =$ -2
            ------------------------------------------------
            """
            
    if angular == "72":
        if poly_degree == "p = 1":
            load_gif("angular72_p1.gif")
            r"""
            -----------------------------------------------
            * Число ячеек сетки: 12101
            * Число узлов сетки: 6296
            * Число искомых дискретных значений: 24692
            * Макс. завихренность: 12.520288
            * Мин. завихренность: -28.260349
            * Число итераций: 16
            * $\Gamma =$ -2
            ------------------------------------------------
            """
            
        elif poly_degree == "p = 2":
            load_gif("angular72_p2.gif")
            r"""
            -----------------------------------------------
            * Число ячеек сетки: 12101
            * Число узлов сетки: 6296
            * Число искомых дискретных значений: 24692
            * Макс. завихренность: 8.795195
            * Мин. завихренность: -34.980800
            * Число итераций: 29
            * $\Gamma =$ -2
            ------------------------------------------------
            """
            
        elif poly_degree == "p = 3":
            load_gif("angular72_p3.gif")
            r"""
            -----------------------------------------------
            * Число ячеек сетки: 12101
            * Число узлов сетки: 6296
            * Число искомых дискретных значений: 24692
            * Макс. завихренность: 9.530891
            * Мин. завихренность: -30.884347
            * Число итераций: 29
            * $\Gamma =$ -2
            ------------------------------------------------
            """                
    
